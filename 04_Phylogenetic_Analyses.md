# XX General Title XX
# 4. Phylogenetic Analyses

Program                | Location
---------------------- | --------------------------------------
*bcftools v.1.11*      | (https://github.com/samtools/bcftools)
*PLINK v.1.9*          | (https://www.cog-genomics.org/plink)
*tped2fasta*           | (https://github.com/smlatorreo/misc_tools)
*RAxML-NG v.1.0.3*     | (https://github.com/amkozlov/raxml-ng)
*ClonalFrameML v.1.12* | (https://github.com/xavierdidelot/clonalframeml)
*BactDating*           | (https://github.com/xavierdidelot/BactDating)
*R*                    | (https://cran.r-project.org/)

After removing those samples where recombination is present (see [3. Recombination analyses](/03_Recombination_Analyses.md)), we thinned the dataset to the B71 clonal lineag and the PY0925 cluster (also clonal) which can be used as an outgroup. We kept positions with no-missing data.

```bash
bcftools view -a -S B71clust_PY0925clust.list wheat-blast.snps.filtered.vcf.gz |
bcftools view -m2 -M2 -g ^miss |
bgzip > B71clust_PY0925clust.snps.filtered.fullinfo.vcf.gz
```

## Maximum-Likelihood (ML) phylogeny
We converted the VCF file into a pseudo-fasta format to have whole-genome concatenated SNPs per isoalte as a suitable input for the phylogenetic analyses.

```bash
plink --allow-extra-chr --vcf B71clust_PY0925clust.snps.filtered.fullinfo.vcf.gz \
--recode transpose --out B71clust_PY0925clust.snps.filtered.fullinfo

tped2fasta B71clust_PY0925clust.snps.filtered.fullinfo > B71clust_PY0925clust.snps.filtered.fullinfo.fasta
```
Files can be found at: [B71clust_PY0925clust.snps.filtered.fullinfo.tped](/data/04_Phylogeny/B71clust_PY0925clust.snps.filtered.fullinfo.tped) ; [B71clust_PY0925clust.snps.filtered.fullinfo.tfam](/data/04_Phylogeny/B71clust_PY0925clust.snps.filtered.fullinfo.tfam) ; [B71clust_PY0925clust.snps.filtered.fullinfo.fasta](/data/04_Phylogeny/B71clust_PY0925clust.snps.filtered.fullinfo.fasta).  
Then, we generated a ML phylogeny using RAxML-NG with a GTR+G substituion model and 1,000 bootstrap replicates.
```bash
raxml-ng --all --msa B71clust_PY0925clust.snps.filtered.fullinfo.fasta --msa-format FASTA \
--data-type DNA --model GTR+G --bs-trees 1000
```
Best tree with bootstrap support values can be found at: [B71clust_PY0925clust.snps.filtered.fullinfo.raxml.support](/data/04_Phylogeny/B71clust_PY0925clust.snps.filtered.fullinfo.raxml.support)

## Removing homoplasy
As low bootstrap values can be caused due to presence homoplasies, we used *ClonalFrameML* in order to detect and remove those events from the calculated phylogeny.

```bash
ClonalFrameML B71clust_PY0925clust.snps.filtered.fullinfo.fasta.raxml.bestTree B71clust_PY0925clust.snps.filtered.fullinfo.fasta
```
We used the output of *ClonalFrameML* as input for the dating analyses (see Dating the Phylogeny).  

Furthermore, in order to test the effect of removing all targeted regions with homoplasies on the ML phylogenetic reconstruction, we used the output file *_prefix_.importation_status.txt* to remove all the regions from the original concatenated-SNPs alignment. For this purpose we used the custom *Python* scripts *get_list_of_SNPs_with_homoplasy.py* and *clean_fasta.py*
```bash
python clean_homoplasy_from_fasta.py B71clust_PY0925clust.snps.filtered.fullinfo.importation_status.txt \
B71clust_PY0925clust.snps.filtered.fullinfo.fasta > B71clust_PY0925clust.snps.filtered.fullinfo.clean.fasta \
2> B71clust_PY0925clust.snps.filtered.fullinfo.homoplasy.fasta
```

Finally, we used the cleaned fasta alignment and computed again a ML phylogeny with RAxML-NG
```bash
raxml-ng --all --msa B71clust_PY0925clust.snps.filtered.fullinfo.clean.fasta --data-type DNA \
--model GTR+G --bs-trees 1000
```
Note: Bootstrap values in the main nodes improved

## Dating the phylogeny
Temporal Signal

We used the homoplasy-free tree generated by *ClonalFrameML* as input [B71clust_PY0925clust.snps.filtered.fullinfo.labelled_tree.newick](/data/04_Phylogeny/B71_and_PY0925_clust.snps.filtered.fullinfo.labelled_tree.newick), using the isoalte collection dates [B71_and_PY0925_clust.dates](/data/04_Phylogeny/B71_and_PY0925_clust.dates).
```{r}
# R
library(ape)
library(scales)

# Load ML tree
t=read.tree('B71clust_PY0925clust.snps.filtered.fullinfo.labelled_tree.newick)

# Compute pairwise cophenetic / patristic distances and select distances to PY0925
distances <- cophenetic(t)
dist_to_PY0925 <- distances[colnames(distances) == 'PY0925', ]

# Just keep distances of the B71 lineage (remove those from isolates: '053i','PY0925','117','37','12.1.037')
dist_to_PY0925 <- dist_to_PY0925[! names(d_to_PY0925) %in% c('053i','PY0925','117','37','12.1.037')]

# Load the collection dates and match them with the distances
dt <- read.table('B71_and_PY0925_clust.dates', header = FALSE)
dts <- c()
for(n in names(dist_to_PY0925)){dts <- c(dts, dt[dt[,1] == n, 2])}
m <- data.frame(Coll_Year = dts, Patr_dist_to_PY0925 = dist_to_PY0925)

plot(m)
legend('topleft', paste("Pearson\'s r =", round(cor(m$Coll_Year, m$Patr_dist_to_PY0925), 2)), bty = 'n')
abline(lm(m$Distance ~ m$Date), lty = 2)
cor.test(m$Coll_Year, m$Patr_dist_to_PY0925)
```
![Distances vs Dates](/data/04_Phylogeny/Dist_vs_Dates.png)

Later, we tested the robustness of the correlation by recalculating the correlation coefficient of 1,000 sampling with replacement repetitions. Conversely, dates and distances were randomly permutated (1,000 times) and again, the correlation coefficient was calculated.
```{r}
set.seed(123)
resamplings <- c()
permutations <- c()
for(i in 1:1000){
	nm <- m[sample(nrow(m), replace = T), ]
	p <- cor(nm$Coll_Year, nm$Patr_dist_to_PY0925)
	resamplings <- c(resamplings, p)
	nmp <- cbind(sample(m$Coll_Year, replace = F), m$Patr_dist_to_PY0925)
	p <- cor(nmp[,1], nmp[,2])
	permutations <- c(permutations, p)
}
boxplot(cbind(resamplings, permutations), outline = FALSE)
```
![Resampling and Permutation](/data/04_Phylogeny/Resampling_Permutation.png)

Finally, we used *BactDating* to build a dated phylogeny. We utilized the function *loadCFML* to use the *ClonalFrameML's* output directly as the input.
```{r}
# R
library(BactDating)

tree = loadCFML('B71_and_PY0925_clust.snps.filtered.fullinfo')
rooted = initRoot(tree, dts, mtry = 1000)

rslt = bactdate(rooted, dts, nbIts = 1000000, thin = 1000, updateRoot = F, showProgress = T)

```
